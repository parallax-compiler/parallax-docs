<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validation - Parallax Documentation</title>
    <link rel="stylesheet" href="../static/style.css">
    <style>
        .test-step {
            background: #f5f5f5;
            border-left: 4px solid #4CAF50;
            padding: 15px;
            margin: 20px 0;
        }
        .test-step h3 {
            margin-top: 0;
            color: #4CAF50;
        }
        .test-result {
            background: #e8f5e9;
            border: 1px solid #4CAF50;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .pass {
            color: #4CAF50;
            font-weight: bold;
        }
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 10px 0;
        }
        .pattern-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <nav>
        <div class="logo">Parallax</div>
        <ul>
            <li><a href="../index.html">Home</a></li>
            <li><a href="quickstart.html">Quick Start</a></li>
            <li><a href="api.html">API</a></li>
            <li><a href="examples.html">Examples</a></li>
            <li><a href="validation.html" class="active">Validation</a></li>
        </ul>
    </nav>

    <div class="container">
        <h1>Unified Memory Validation</h1>

        <p class="intro">
            This page documents the comprehensive validation of Parallax's unified memory system
            with software-based dirty tracking. All tests verify correct CPU-GPU synchronization
            and optimal performance by avoiding unnecessary data transfers.
        </p>

        <h2>Test Overview</h2>
        <p>
            The unified memory test validates that:<br>
            <span class="pass">✓</span> GPU-only kernel loops keep data on the GPU (no CPU-GPU copies)<br>
            <span class="pass">✓</span> CPU access after GPU kernels triggers automatic GPU→CPU synchronization<br>
            <span class="pass">✓</span> CPU modifications are visible to subsequent GPU kernels<br>
            <span class="pass">✓</span> Bidirectional data flow maintains numerical consistency
        </p>

        <h2>Test Configuration</h2>
        <div class="code-block">
Platform: NVIDIA GeForce GTX 980M
Data Size: 1,000,000 floats (4 MB)
Memory Model: Software-based unified memory with dirty tracking
Verification: All 9 test steps passed
        </div>

        <h2>Test Steps</h2>

        <div class="test-step">
            <h3>Step 1: CPU Initialization</h3>
            <p><strong>Operation:</strong> Allocate and initialize 1M floats on CPU</p>
            <div class="code-block">
std::vector&lt;float, parallax::allocator&lt;float&gt;&gt; data(1000000, 1.0f);
            </div>
            <div class="test-result">
                <strong>Result:</strong> data[0] = 1.0<br>
                <strong>Memory State:</strong> CPU dirty, GPU clean
            </div>
        </div>

        <div class="test-step">
            <h3>Step 2: First GPU Kernel</h3>
            <p><strong>Operation:</strong> Execute GPU kernel: x *= 2.0</p>
            <div class="code-block">
std::for_each(std::execution::par, data.begin(), data.end(),
              [](float& x) { x *= 2.0f; });
            </div>
            <div class="test-result">
                <strong>Expected:</strong> CPU→GPU copy triggered (first GPU access)<br>
                <strong>SPIR-V Generated:</strong> 223 words (892 bytes)<br>
                <strong>Memory State:</strong> GPU dirty, CPU clean<br>
                <span class="pass">✓ PASS</span>
            </div>
        </div>

        <div class="test-step">
            <h3>Step 3: GPU-Only Loop (10 Kernels)</h3>
            <p><strong>Operation:</strong> Execute 10 kernels without CPU access</p>
            <div class="code-block">
for (int i = 0; i < 10; i++) {
    std::for_each(std::execution::par, data.begin(), data.end(),
                  [](float& x) { x *= 2.0f; });
}
            </div>
            <div class="test-result">
                <strong>Expected:</strong> NO data copies (data stays on GPU)<br>
                <strong>Kernel Launches:</strong> 10 consecutive launches<br>
                <strong>Memory Transfers:</strong> 0 (zero)<br>
                <span class="pass">✓ PASS: Zero-copy GPU loop verified</span>
            </div>
        </div>

        <div class="test-step">
            <h3>Step 4: CPU Read After GPU</h3>
            <p><strong>Operation:</strong> Read data[0] from CPU</p>
            <div class="code-block">
float value = data[0];
            </div>
            <div class="test-result">
                <strong>Expected:</strong> GPU→CPU copy triggered<br>
                <strong>Result:</strong> data[0] = 2048.0<br>
                <strong>Validation:</strong> 1.0 × 2^11 = 2048.0<br>
                <strong>Memory State:</strong> CPU dirty, GPU clean<br>
                <span class="pass">✓ PASS: Synchronization triggered correctly</span>
            </div>
        </div>

        <div class="test-step">
            <h3>Step 5: CPU Modification</h3>
            <p><strong>Operation:</strong> Modify data from CPU</p>
            <div class="code-block">
data[0] = 100.0f;
            </div>
            <div class="test-result">
                <strong>Result:</strong> data[0] = 100.0<br>
                <strong>Memory State:</strong> CPU dirty, GPU stale
            </div>
        </div>

        <div class="test-step">
            <h3>Step 6: GPU Kernel After CPU Write</h3>
            <p><strong>Operation:</strong> Execute GPU kernel after CPU modification</p>
            <div class="code-block">
std::for_each(std::execution::par, data.begin(), data.end(),
              [](float& x) { x /= 2.0f; });
            </div>
            <div class="test-result">
                <strong>Expected:</strong> CPU→GPU copy triggered (CPU dirty)<br>
                <strong>Memory State:</strong> GPU dirty, CPU clean<br>
                <span class="pass">✓ PASS</span>
            </div>
        </div>

        <div class="test-step">
            <h3>Step 7: CPU Read to Verify</h3>
            <p><strong>Operation:</strong> Read modified value from CPU</p>
            <div class="code-block">
float value = data[0];
            </div>
            <div class="test-result">
                <strong>Expected:</strong> GPU→CPU copy triggered<br>
                <strong>Result:</strong> data[0] = 50.0<br>
                <strong>Validation:</strong> 100.0 / 2.0 = 50.0<br>
                <span class="pass">✓ PASS: CPU modifications correctly propagated to GPU</span>
            </div>
        </div>

        <div class="test-step">
            <h3>Step 8: Second GPU-Only Loop (5 Kernels)</h3>
            <p><strong>Operation:</strong> Execute 5 kernels: x *= 1.1 each</p>
            <div class="code-block">
for (int i = 0; i < 5; i++) {
    std::for_each(std::execution::par, data.begin(), data.end(),
                  [](float& x) { x *= 1.1f; });
}
            </div>
            <div class="test-result">
                <strong>Expected:</strong> NO data copies (data stays on GPU)<br>
                <strong>Kernel Launches:</strong> 5 consecutive launches<br>
                <strong>Memory Transfers:</strong> 0 (zero)<br>
                <span class="pass">✓ PASS: Zero-copy GPU loop verified</span>
            </div>
        </div>

        <div class="test-step">
            <h3>Step 9: Final Consistency Check</h3>
            <p><strong>Operation:</strong> Verify final value on CPU</p>
            <div class="code-block">
float value = data[0];
float expected = 50.0 * pow(1.1, 5);
            </div>
            <div class="test-result">
                <strong>Expected:</strong> GPU→CPU copy triggered<br>
                <strong>Result:</strong> data[0] = 80.5255<br>
                <strong>Expected:</strong> 50.0 × 1.1^5 = 80.5255<br>
                <strong>Precision:</strong> Exact match (floating point accurate)<br>
                <span class="pass">✓ PASS: Final consistency verified</span>
            </div>
        </div>

        <h2>Test Summary</h2>
        <div class="test-result">
            <h3 class="pass">✓ ALL TESTS PASSED</h3>
            <ul>
                <li><span class="pass">✓</span> CPU initialization works</li>
                <li><span class="pass">✓</span> First GPU access triggers CPU→GPU copy</li>
                <li><span class="pass">✓</span> GPU-only loops avoid unnecessary copies</li>
                <li><span class="pass">✓</span> CPU read after GPU triggers GPU→CPU copy</li>
                <li><span class="pass">✓</span> CPU modifications visible to GPU</li>
                <li><span class="pass">✓</span> GPU modifications visible to CPU</li>
                <li><span class="pass">✓</span> Bidirectional synchronization works correctly</li>
            </ul>
        </div>

        <h2>Pointer Pattern Support</h2>
        <p>
            Parallax automatically traces various iterator and pointer patterns back to their
            source containers to inject the correct allocators:
        </p>

        <div class="pattern-box">
            <h3>Pattern 1: Container Member Calls</h3>
            <div class="code-block">
std::vector&lt;float&gt; vec(1000);
std::for_each(par, vec.begin(), vec.end(), lambda);
            </div>
            <p><strong>Tracing:</strong> vec.begin() → vec (container variable)<br>
            <strong>Transformation:</strong> std::vector&lt;float&gt; → std::vector&lt;float, parallax::allocator&lt;float&gt;&gt;</p>
        </div>

        <div class="pattern-box">
            <h3>Pattern 2: Free Function Calls</h3>
            <div class="code-block">
std::vector&lt;float&gt; vec(1000);
std::for_each(par, std::begin(vec), std::end(vec), lambda);
            </div>
            <p><strong>Tracing:</strong> std::begin(vec) → vec (argument analysis)<br>
            <strong>Transformation:</strong> Allocator injected into vec</p>
        </div>

        <div class="pattern-box">
            <h3>Pattern 3: Raw Pointers from .data()</h3>
            <div class="code-block">
std::vector&lt;float&gt; vec(1000);
float* ptr = vec.data();
std::for_each(par, ptr, ptr + 1000, lambda);
            </div>
            <p><strong>Tracing:</strong> ptr → vec.data() → vec (call chain analysis)<br>
            <strong>Transformation:</strong> Allocator injected into vec</p>
        </div>

        <div class="pattern-box">
            <h3>Pattern 4: Direct Pointer Variables</h3>
            <div class="code-block">
std::vector&lt;CellData&gt; lattice_vect(size);
CellData* lattice = &lattice_vect[0];
std::for_each(par, lattice, lattice + size, functor);
            </div>
            <p><strong>Tracing:</strong> lattice → &lattice_vect[0] → lattice_vect (initialization analysis)<br>
            <strong>Transformation:</strong> Allocator injected into lattice_vect</p>
        </div>

        <h2>Performance Impact</h2>
        <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
            <thead>
                <tr style="background: #4CAF50; color: white;">
                    <th style="padding: 10px; text-align: left;">Scenario</th>
                    <th style="padding: 10px; text-align: right;">Memory Transfers</th>
                    <th style="padding: 10px; text-align: right;">Performance</th>
                </tr>
            </thead>
            <tbody>
                <tr style="background: #f9f9f9;">
                    <td style="padding: 10px;">First GPU access</td>
                    <td style="padding: 10px; text-align: right;">1 CPU→GPU copy</td>
                    <td style="padding: 10px; text-align: right;">Expected overhead</td>
                </tr>
                <tr>
                    <td style="padding: 10px;">GPU-only loop (N kernels)</td>
                    <td style="padding: 10px; text-align: right;">0 copies</td>
                    <td style="padding: 10px; text-align: right;"><strong>Optimal</strong></td>
                </tr>
                <tr style="background: #f9f9f9;">
                    <td style="padding: 10px;">CPU access after GPU</td>
                    <td style="padding: 10px; text-align: right;">1 GPU→CPU copy</td>
                    <td style="padding: 10px; text-align: right;">On-demand sync</td>
                </tr>
                <tr>
                    <td style="padding: 10px;">GPU after CPU modification</td>
                    <td style="padding: 10px; text-align: right;">1 CPU→GPU copy</td>
                    <td style="padding: 10px; text-align: right;">Automatic sync</td>
                </tr>
            </tbody>
        </table>

        <h2>LBM Benchmark Results</h2>
        <div class="test-result">
            <p><strong>Workload:</strong> Lattice Boltzmann Method (128³ grid, 100 iterations)</p>
            <p><strong>CPU Sequential:</strong> 36,270 ms</p>
            <p><strong>GPU Parallax:</strong> 190.4 ms</p>
            <p><strong>Speedup:</strong> <span style="font-size: 1.2em; color: #4CAF50;"><strong>190.5×</strong></span></p>
            <p><strong>MLUPS:</strong> 109.9 Million Lattice Updates Per Second</p>
        </div>

        <p style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd;">
            <strong>Test Date:</strong> December 26, 2025<br>
            <strong>Platform:</strong> NVIDIA GeForce GTX 980M (Maxwell architecture, 1280 CUDA cores)<br>
            <strong>Parallax Version:</strong> 2.0 (Clang CodeGen with automatic injection)
        </p>
    </div>
</body>
</html>
